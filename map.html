function createAllStationsMap() {
  const allStationsMap = L.map('map4', {
    scrollWheelZoom: false
  });

  L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
    attribution: '&copy; OpenStreetMap & CartoDB'
  }).addTo(allStationsMap);

  fetch('https://raw.githubusercontent.com/PublicaMundi/MappingAPI/master/data/geojson/us-states.json')
    .then(r => r.json()).then(data => {
      data.features.forEach(feat => {
        L.geoJSON(feat, {
          style: {
            color: 'black',
            weight: 1,
            opacity: 1,
            fillOpacity: 0
          }
        }).addTo(allStationsMap);
      });
    });

  mapConfigs.forEach(cfg => {
    let largestRange = cfg.ranges.reduce((max, r) => r.m > max ? r.m : max, 0);
    const circle = L.circle(cfg.center, {
      radius: largestRange,
      fillColor: cfg.color,       // <-- Color-coded
      fillOpacity: 0.35,
      stroke: false
    }).addTo(allStationsMap);

    // Optional: Add tooltip & click
    if (cfg.tooltip && cfg.url) {
      circle.bindTooltip(cfg.tooltip, {
        permanent: true,
        direction: 'center',
        className: 'circle-label'
      });
      circle.on('click', () => window.open(cfg.url, '_blank'));
    }
  });

  const latLngs = [];
  mapConfigs.forEach(cfg => {
    let largestRange = cfg.ranges.reduce((max, r) => r.m > max ? r.m : max, 0);
    const center = L.latLng(cfg.center[0], cfg.center[1]);
    latLngs.push(center);

    const radiusDegrees = largestRange / 111000;
    latLngs.push(L.latLng(center.lat + radiusDegrees, center.lng));
    latLngs.push(L.latLng(center.lat - radiusDegrees, center.lng));
    latLngs.push(L.latLng(center.lat, center.lng + radiusDegrees));
    latLngs.push(L.latLng(center.lat, center.lng - radiusDegrees));
  });

  const bounds = L.latLngBounds(latLngs);
  setTimeout(() => {
    allStationsMap.invalidateSize();
    allStationsMap.fitBounds(bounds, { padding: [50, 50] });
  }, 300);

  maps.push(allStationsMap);
}
