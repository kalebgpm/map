<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Typing Racer — Locked Until Correct</title>
<style>
  :root{
    --bg:#0b0f16; --muted:#9aa7d1; --good:#6bf59a; --bad:#ff6b6b; --accent:#ffd66b;
  }
  html,body{height:100%;margin:0;font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;background:var(--bg);color:#e6eef8}
  .wrap{max-width:980px;margin:18px auto;padding:18px;display:flex;flex-direction:column;gap:12px}
  h1{margin:0;font-size:20px}
  .game {background:linear-gradient(180deg,#07101a,#081827);padding:12px;border-radius:8px;border:2px solid rgba(255,255,255,0.03);box-shadow:0 8px 30px rgba(0,0,0,0.7)}
  .canvas-wrap{background:linear-gradient(180deg,#061019,#07121a);padding:10px;border-radius:6px;display:flex;justify-content:center}
  canvas{width:920px;height:220px;background:linear-gradient(180deg,#07121c,#041018);image-rendering:pixelated;border:2px solid rgba(255,255,255,0.03)}
  .controls{display:flex;gap:8px;align-items:center;margin-top:10px}
  button{background:#0e1724;color:var(--muted);border:1px solid rgba(255,255,255,0.03);padding:8px 10px;border-radius:6px;cursor:pointer}
  .prompt-area{margin-top:12px;background:linear-gradient(180deg,#08121b,#06101a);padding:10px;border-radius:6px;border:1px solid rgba(255,255,255,0.02)}
  .typed-line{font-size:18px;min-height:28px;word-break:break-word}
  .expected-line{font-size:16px;color:var(--muted);margin-top:6px;white-space:pre-wrap}
  .wrong { color: var(--bad); background: rgba(255,90,90,0.04); padding:0 2px; border-radius:2px;}
  .correct { color: var(--good); }
  .stats-box{margin-left:auto;color:var(--muted);font-size:13px}
  .live-stats{display:flex;gap:10px;align-items:center}
  .small-muted{color:var(--muted);font-size:12px}
  .modal-backdrop{position:fixed;inset:0;background:rgba(2,6,12,0.6);display:flex;align-items:center;justify-content:center;z-index:50}
  .modal{background:#06101a;padding:20px;border-radius:10px;border:2px solid rgba(255,255,255,0.04);width:min(720px,92vw);color:#eaf0ff}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:8px}
  .modal button{margin-top:12px}
  @media(max-width:760px){ canvas{width:100%;height:200px} .stats-box{display:none} }
</style>
</head>
<body>
<div class="wrap">
  <div style="display:flex;align-items:center;gap:12px">
    <h1>Pixel Typing Racer</h1>
    <div class="small-muted">Locked until correct: wrong character locks input (no backspace). Spacebar works.</div>
  </div>

  <div class="game">
    <div class="canvas-wrap">
      <canvas id="raceCanvas" width="880" height="200"></canvas>
    </div>

    <div class="controls">
      <button id="newBtn">New Race</button>
      <button id="skipBtn">Skip Prompt</button>
      <button id="randomToggle">Random Prompts: ON</button>
      <div class="stats-box">
        <div class="live-stats">
          <div>WPM: <strong id="liveWpm">0</strong></div>
          <div>CPS: <strong id="liveCps">0.00</strong></div>
          <div>Errors: <strong id="liveErrors">0</strong></div>
          <div>Progress: <strong id="liveProgress">0%</strong></div>
        </div>
        <div class="small-muted">AI follows your recent speed with randomness.</div>
      </div>
    </div>

    <div class="prompt-area" tabindex="0" id="promptArea">
      <div class="typed-line" id="typedLine"></div>
      <div class="expected-line" id="expectedLine"></div>
      <div style="margin-top:8px" class="small-muted">If you type the wrong character, the game locks until the correct character is typed. Holding keys won't let you cheat.</div>
    </div>
  </div>
</div>

<div id="modalWrap" style="display:none"></div>

<script>
/* ===== PROMPTS ===== */
const PROMPTS = [
  "The steam from the kettle spelled out a secret message.",
  "Moonlight painted silver stripes across the old barn roof.",
  "He traded his umbrella for someone else's smile.",
  "Tiny robots fixed the city's streetlights at dawn.",
  "A lost letter hidden under the floorboards changed everything.",
  "The bakery closed early when the dough refused to rise.",
  "She kept a map of storms in the back of her notebook.",
  "Paper boats carried whispered wishes down the gutter.",
  "The piano knew the name of every late visitor.",
  "A single sunflower grew through the pavement crack.",
  "They found a photograph that was never taken.",
  "Rain tasted like the last day of summer and freedom.",
  "An old key hummed softly whenever birds gathered nearby.",
  "The alley had its own set of rules and a tiny library.",
  "A firefighter rescued a kitten who had ideas about ballet.",
  "He planted clocks instead of seeds and waited for time to grow.",
  "The train left without destination but full of postcards.",
  "The cat had a favorite radio station and a stern opinion.",
  "She collected sunsets and kept them in little glass jars.",
  "The lighthouse blinked messages to ships and passing satellites."
];

/* ===== CANVAS & UI ===== */
const canvas = document.getElementById('raceCanvas');
const ctx = canvas.getContext('2d'); ctx.imageSmoothingEnabled = false;

const START_X = 48;
const FINISH_X = canvas.width - 64;
const TRACK_Y = [44, 118];

const typedLine = document.getElementById('typedLine');
const expectedLine = document.getElementById('expectedLine');
const liveWpm = document.getElementById('liveWpm');
const liveCps = document.getElementById('liveCps');
const liveErrors = document.getElementById('liveErrors');
const liveProgress = document.getElementById('liveProgress');
const newBtn = document.getElementById('newBtn');
const skipBtn = document.getElementById('skipBtn');
const randomToggle = document.getElementById('randomToggle');
const promptArea = document.getElementById('promptArea');
const modalWrap = document.getElementById('modalWrap');

/* ===== STATE ===== */
let randomPrompts = true;
let prompt = "";
let index = 0;                // how many correct chars consumed
let isLocked = false;        // locked until correct char typed
let lockedWrongChar = "";    // shows the wrong char that locked the game
let errors = 0;
let startTime = null;
let finished = false;

/* AI */
let aiIndex = 0;
let aiErrors = 0;
let aiSpeedCPS = 2.2;
let playerTimestamps = [];

/* UTIL */
function pickPrompt(){ return randomPrompts ? PROMPTS[Math.floor(Math.random()*PROMPTS.length)] : PROMPTS[0]; }
function escapeHtml(s){ return (s||'').toString().replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

/* NEW RACE */
function newRace(){
  prompt = pickPrompt();
  index = 0;
  isLocked = false;
  lockedWrongChar = "";
  errors = 0;
  aiIndex = 0;
  aiErrors = 0;
  playerTimestamps = [];
  startTime = null;
  finished = false;
  aiSpeedCPS = 2.2 + Math.random()*0.8;
  modalWrap.style.display = 'none';
  updateDisplays();
  requestAnimationFrame(draw);
}
newRace();

/* INPUT: use keydown to capture repeats, but we control locking so repeats cannot cheat */
window.addEventListener('keydown', e=>{
  // prevent backspace navigation & prevent space scrolling
  if(e.key === 'Backspace'){ e.preventDefault(); return; }
  if(e.code === 'Space') e.preventDefault();

  if(finished) return;

  // only process printable single-character keys and space
  const key = e.key;
  if(key.length !== 1) return;

  if(!startTime) startTime = performance.now();

  // record timestamp for CPS smoothing (only record for keys that attempt to do something)
  const now = performance.now();
  playerTimestamps.push(now);
  while(playerTimestamps.length && playerTimestamps[0] < now - 6000) playerTimestamps.shift();

  const expected = prompt.charAt(index);

  if(isLocked){
    // locked: only allow unlocking if they type the expected char
    if(key === expected){
      // correct -> consume and unlock
      index++;
      isLocked = false;
      lockedWrongChar = "";
    } else {
      // still wrong -> ignore (do not accumulate multiple wrongs or queue), but count a single error per distinct wrong-press event
      // increment errors only on the first wrong press that created the lock (we already counted it when locking)
      // here, if user keeps hitting wrong key, we do NOT add more errors (prevents holding letter to bloat counters)
      // so simply ignore
      return;
    }
  } else {
    // not locked: if matches expected, advance; else lock and record wrong char (single)
    if(key === expected){
      index++;
    } else {
      // wrong char -> create lock and record exactly one wrong char
      isLocked = true;
      lockedWrongChar = key;
      errors++;
    }
  }

  updateDisplays();
  checkFinish();
});

/* Player metrics */
function computePlayerCPS(){
  if(!startTime) return 0;
  const now = performance.now();
  const windowMs = 4000;
  const cutoff = now - windowMs;
  const recent = playerTimestamps.filter(t => t >= cutoff).length;
  return recent / (windowMs/1000);
}
function computePlayerWPM(){
  const cps = computePlayerCPS();
  return Math.round((cps * 60) / 5);
}

/* AI */
function updateAI(dt){
  const playerCps = computePlayerCPS() || 2.2;
  const randFactor = 0.9 + Math.random()*0.3; // 0.9 - 1.2
  const target = Math.max(0.5, playerCps * randFactor);
  const smoothing = 0.09;
  aiSpeedCPS += (target - aiSpeedCPS) * smoothing;
  aiIndex += aiSpeedCPS * dt;
  // small chance of AI error per advanced char
  const approx = aiSpeedCPS * dt;
  for(let i=0;i<Math.floor(approx)+1;i++){
    if(Math.random() < 0.03) aiErrors++;
  }
}

/* DRAW */
function drawTrack(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = '#071420'; ctx.fillRect(0,0,canvas.width,canvas.height);
  for(let t=0;t<2;t++){
    const y = TRACK_Y[t];
    ctx.fillStyle = '#0d2236';
    ctx.fillRect(START_X-16, y-18, FINISH_X - START_X + 32, 44);
    for(let x=START_X; x<FINISH_X; x+=20){
      ctx.fillStyle = (x%40===0)? '#17324a' : '#0f2a40';
      ctx.fillRect(x, y-12, 12, 2);
    }
  }
  ctx.fillStyle = '#fff'; ctx.fillRect(FINISH_X, 18, 6, canvas.height-36);
  for(let i=0;i<8;i++){ ctx.fillStyle = i%2===0? '#000' : '#fff'; ctx.fillRect(FINISH_X+8, 22 + i*18, 12, 12); }
}

function drawCar(x,y,color,label){
  ctx.fillStyle = 'rgba(0,0,0,0.28)'; ctx.fillRect(x+2, y+20, 40, 8);
  ctx.fillStyle = color; ctx.fillRect(x, y, 40, 18); ctx.fillRect(x+8, y-8, 24, 10);
  ctx.fillStyle = '#0b0b0b'; ctx.fillRect(x+4, y+16, 8, 6); ctx.fillRect(x+28, y+16, 8, 6);
  ctx.fillStyle = 'rgba(255,255,255,0.18)'; ctx.fillRect(x+12, y-6, 8, 6); ctx.fillRect(x+22, y-6, 6, 6);
  ctx.fillStyle = '#08101a'; ctx.font = '10px monospace'; ctx.fillText(label, x+6, y+12);
}

function draw(){
  drawTrack();
  const playerProg = Math.min(1, index / Math.max(1, prompt.length));
  const aiProg = Math.min(1, aiIndex / Math.max(1, prompt.length));
  const range = FINISH_X - START_X - 40;
  const playerX = START_X + range * playerProg;
  const aiX = START_X + range * aiProg;
  drawCar(aiX, TRACK_Y[0]-4, '#6ba6ff','AI');
  drawCar(playerX, TRACK_Y[1]-4, '#ff6b6b','YOU');
  ctx.fillStyle = '#13243a'; ctx.fillRect(START_X, TRACK_Y[1] + 32, FINISH_X - START_X, 6);
  ctx.fillStyle = '#2be08a'; ctx.fillRect(START_X, TRACK_Y[1] + 32, (FINISH_X - START_X) * playerProg, 6);
  ctx.fillStyle = '#13243a'; ctx.fillRect(START_X, TRACK_Y[0] + 32, FINISH_X - START_X, 6);
  ctx.fillStyle = '#6ba6ff'; ctx.fillRect(START_X, TRACK_Y[0] + 32, (FINISH_X - START_X) * aiProg, 6);
  if(finished){ ctx.fillStyle = '--accent'; ctx.font='18px monospace'; ctx.fillText('RACE FINISHED', canvas.width/2 - 72, 28); }
  liveCps.innerText = computePlayerCPS().toFixed(2);
  liveWpm.innerText = computePlayerWPM();
  liveErrors.innerText = errors;
  liveProgress.innerText = Math.round(playerProg*100) + '%';
}

/* DISPLAY PROMPT & TYPED */
function updateDisplays(){
  const correctText = escapeHtml(prompt.slice(0, index));
  const nextChar = prompt.charAt(index) || '';
  const remaining = escapeHtml(prompt.slice(index + (isLocked && !(!lockedWrongChar) ? 0 : 0))); // remaining shown after current expected char
  // Show: correct portion, then either locked wrong char (red) or nothing, then rest (expected)
  let lockedHtml = '';
  if(isLocked && lockedWrongChar){
    lockedHtml = `<span class="wrong">${escapeHtml(lockedWrongChar)}</span>`;
  }
  typedLine.innerHTML = `<span class="correct">${correctText}</span>` + lockedHtml;
  // expected line: show the upcoming expected char + remaining for clarity
  expectedLine.innerHTML = escapeHtml(prompt.slice(index + (isLocked && !lockedWrongChar ? 0 : 0)));
}

/* FINISH CHECK & STATS */
function checkFinish(){
  if(index >= prompt.length && !finished){
    finished = true;
    finishRace();
    return;
  }
  if(Math.floor(aiIndex) >= prompt.length && !finished){
    finished = true;
    finishRace();
    return;
  }
}

function finishRace(){
  const end = performance.now();
  const elapsed = ((end - (startTime||end))/1000) || 0;
  const cps = (index / Math.max(elapsed, 0.0001));
  const wpm = Math.round((cps*60)/5);
  const accuracy = Math.round(100 * (Math.max(0,index - errors) / Math.max(1, index)));
  const winner = (index >= prompt.length && Math.floor(aiIndex) >= prompt.length) ? (index >= Math.floor(aiIndex) ? 'You' : 'AI') : (index >= prompt.length ? 'You' : 'AI');
  showStatsModal({
    prompt,
    elapsed: elapsed.toFixed(2),
    cps: cps.toFixed(2),
    wpm,
    errors,
    aiErrors,
    aiCps: aiSpeedCPS.toFixed(2),
    accuracy,
    winner
  });
}

/* STATS MODAL */
function showStatsModal(stats){
  modalWrap.style.display = 'flex';
  modalWrap.innerHTML = `
    <div class="modal-backdrop" id="backdrop">
      <div class="modal" role="dialog" aria-modal="true">
        <h2>Race Results — ${escapeHtml(stats.winner)}</h2>
        <div style="color:var(--muted);margin-top:6px">Prompt: "${escapeHtml(stats.prompt)}"</div>
        <div class="grid">
          <div><strong>Time</strong><div>${stats.elapsed} s</div></div>
          <div><strong>WPM</strong><div>${stats.wpm}</div></div>
          <div><strong>CPS (you)</strong><div>${stats.cps}</div></div>
          <div><strong>CPS (AI)</strong><div>${stats.aiCps}</div></div>
          <div><strong>Errors (you)</strong><div>${stats.errors}</div></div>
          <div><strong>Errors (AI)</strong><div>${stats.aiErrors}</div></div>
          <div><strong>Accuracy</strong><div>${stats.accuracy}%</div></div>
          <div><strong>Winner</strong><div>${escapeHtml(stats.winner)}</div></div>
        </div>
        <div style="display:flex;gap:8px;justify-content:flex-end;">
          <button id="modalNew">New Race</button>
          <button id="modalClose">Close</button>
        </div>
      </div>
    </div>
  `;
  document.getElementById('modalNew').addEventListener('click', ()=>{
    modalWrap.style.display = 'none';
    newRace();
  });
  document.getElementById('modalClose').addEventListener('click', ()=>{ modalWrap.style.display = 'none'; });
}

/* MAIN LOOP */
let lastFrame = performance.now();
function mainLoop(now){
  const dt = (now - lastFrame)/1000;
  lastFrame = now;
  if(!finished){
    updateAI(dt);
    draw();
    checkFinish();
  }
  requestAnimationFrame(mainLoop);
}
requestAnimationFrame(mainLoop);

/* BUTTONS & UI */
newBtn.addEventListener('click', ()=>{ newRace(); promptArea.focus(); });
skipBtn.addEventListener('click', ()=>{ newRace(); promptArea.focus(); });
randomToggle.addEventListener('click', ()=>{ randomPrompts = !randomPrompts; randomToggle.innerText = `Random Prompts: ${randomPrompts ? 'ON' : 'OFF'}`; });

promptArea.addEventListener('click', ()=> promptArea.focus());
promptArea.focus();
updateDisplays();

</script>
</body>
</html>
