<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pixel Typing Racer — Error Queue</title>
<style>
  :root{
    --bg:#0b0f16;
    --panel:#0f1724;
    --muted:#9aa7d1;
    --good:#6bf59a;
    --bad:#ff6b6b;
    --accent:#ffd66b;
  }
  html,body{height:100%;margin:0;font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;background:var(--bg);color:#e6eef8}
  .wrap{max-width:980px;margin:18px auto;padding:18px;display:flex;flex-direction:column;gap:12px}
  h1{margin:0;font-size:20px}
  .game {background:linear-gradient(180deg,#07101a,#081827);padding:12px;border-radius:8px;border:2px solid rgba(255,255,255,0.03);box-shadow:0 8px 30px rgba(0,0,0,0.7)}
  .canvas-wrap{background:linear-gradient(180deg,#061019,#07121a);padding:10px;border-radius:6px;display:flex;justify-content:center}
  canvas{width:920px;height:220px;background:linear-gradient(180deg,#07121c,#041018);image-rendering:pixelated;border:2px solid rgba(255,255,255,0.03)}
  .controls{display:flex;gap:8px;align-items:center;margin-top:10px}
  button{background:#0e1724;color:var(--muted);border:1px solid rgba(255,255,255,0.03);padding:8px 10px;border-radius:6px;cursor:pointer}
  .prompt-area{margin-top:12px;background:linear-gradient(180deg,#08121b,#06101a);padding:10px;border-radius:6px;border:1px solid rgba(255,255,255,0.02)}
  .typed-line{font-size:18px;min-height:28px}
  .expected-line{font-size:16px;color:var(--muted);margin-top:6px}
  .wrong { color: var(--bad); background: rgba(255,90,90,0.04); padding:0 2px; border-radius:2px;}
  .correct { color: var(--good); }
  .stats-box{margin-left:auto;color:var(--muted);font-size:13px}
  .live-stats{display:flex;gap:10px;align-items:center}
  .small-muted{color:var(--muted);font-size:12px}
  /* modal */
  .modal-backdrop{position:fixed;inset:0;background:rgba(2,6,12,0.6);display:flex;align-items:center;justify-content:center;z-index:50}
  .modal{background:#06101a;padding:20px;border-radius:10px;border:2px solid rgba(255,255,255,0.04);width:min(720px,92vw);color:#eaf0ff}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:8px}
  .modal button{margin-top:12px}
  @media(max-width:760px){
    canvas{width:100%;height:200px}
    .stats-box{display:none}
  }
</style>
</head>
<body>
<div class="wrap">
  <div style="display:flex;align-items:center;gap:12px">
    <h1>Pixel Typing Racer</h1>
    <div class="small-muted">Type to drive — errors queue in red (no backspace). Spacebar works.</div>
  </div>

  <div class="game">
    <div class="canvas-wrap">
      <canvas id="raceCanvas" width="880" height="200"></canvas>
    </div>

    <div class="controls">
      <button id="newBtn">New Race</button>
      <button id="skipBtn">Skip Prompt</button>
      <button id="randomToggle">Random Prompts: ON</button>
      <div class="stats-box">
        <div class="live-stats">
          <div>WPM: <strong id="liveWpm">0</strong></div>
          <div>CPS: <strong id="liveCps">0.00</strong></div>
          <div>Errors: <strong id="liveErrors">0</strong></div>
          <div>Progress: <strong id="liveProgress">0%</strong></div>
        </div>
        <div class="small-muted">AI follows your recent speed with randomness.</div>
      </div>
    </div>

    <div class="prompt-area" tabindex="0" id="promptArea">
      <div class="typed-line" id="typedLine"></div>
      <div class="expected-line" id="expectedLine"></div>
      <div style="margin-top:8px" class="small-muted">No backspace. Wrong characters shown red (queued). Car only moves when the next character is typed correctly.</div>
    </div>
  </div>
</div>

<div id="modalWrap" style="display:none"></div>

<script>
/* ======= PROMPTS ======= */
const PROMPTS = [
  "The steam from the kettle spelled out a secret message.",
  "Moonlight painted silver stripes across the old barn roof.",
  "He traded his umbrella for someone else's smile.",
  "Tiny robots fixed the city's streetlights at dawn.",
  "A lost letter hidden under the floorboards changed everything.",
  "The bakery closed early when the dough refused to rise.",
  "She kept a map of storms in the back of her notebook.",
  "Paper boats carried whispered wishes down the gutter.",
  "The piano knew the name of every late visitor.",
  "A single sunflower grew through the pavement crack.",
  "They found a photograph that was never taken.",
  "Rain tasted like the last day of summer and freedom.",
  "An old key hummed softly whenever birds gathered nearby.",
  "The alley had its own set of rules and a tiny library.",
  "A firefighter rescued a kitten who had ideas about ballet.",
  "He planted clocks instead of seeds and waited for time to grow.",
  "The train left without destination but full of postcards.",
  "The cat had a favorite radio station and a stern opinion.",
  "She collected sunsets and kept them in little glass jars.",
  "The lighthouse blinked messages to ships and passing satellites."
];

/* ======= CANVAS & DRAWING ======= */
const canvas = document.getElementById('raceCanvas');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;

const START_X = 48;
const FINISH_X = canvas.width - 64;
const TRACK_Y = [44, 118]; // AI at top (0), Player at bottom (1)

/* ======= UI Refs ======= */
const typedLine = document.getElementById('typedLine');
const expectedLine = document.getElementById('expectedLine');
const liveWpm = document.getElementById('liveWpm');
const liveCps = document.getElementById('liveCps');
const liveErrors = document.getElementById('liveErrors');
const liveProgress = document.getElementById('liveProgress');
const newBtn = document.getElementById('newBtn');
const skipBtn = document.getElementById('skipBtn');
const randomToggle = document.getElementById('randomToggle');
const promptArea = document.getElementById('promptArea');
const modalWrap = document.getElementById('modalWrap');

/* ======= GAME STATE ======= */
let randomPrompts = true;
let prompt = "";
let index = 0;             // how many correct characters player has advanced (progress)
let errorQueue = "";       // queued wrong characters shown in red (Option C)
let errors = 0;            // total wrong chars typed by player
let startTime = null;
let finished = false;

/* AI state */
let aiIndex = 0;           // float progress (chars)
let aiErrors = 0;
let aiSpeedCPS = 2.2;     // current ai speed (chars per second)
let playerTimestamps = []; // timestamps of player's typed events for recent cps

/* ======= UTIL ======= */
function pickPrompt(){
  if(!randomPrompts) return PROMPTS[0];
  return PROMPTS[Math.floor(Math.random()*PROMPTS.length)];
}
function escapeHtml(s){ return (s||'').toString().replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
function formatTime(sec){ const m = Math.floor(sec/60).toString().padStart(2,'0'); const s = Math.floor(sec%60).toString().padStart(2,'0'); return `${m}:${s}`; }

/* ======= RESET / NEW RACE ======= */
function newRace(){
  prompt = pickPrompt();
  index = 0;
  errorQueue = "";
  errors = 0;
  aiIndex = 0;
  aiErrors = 0;
  playerTimestamps = [];
  startTime = null;
  finished = false;
  aiSpeedCPS = 2.2 + Math.random()*0.8; // baseline
  modalWrap.style.display = 'none';
  updateDisplays();
  requestAnimationFrame(draw); // fresh draw
}
newRace();

/* ======= INPUT HANDLING ======= */
// prevent backspace default navigation & disable backspace functionality
window.addEventListener('keydown', e=>{
  if(e.key === 'Backspace'){ e.preventDefault(); return; }
  // allow space default to not scroll the page
  if(e.code === 'Space') e.preventDefault();
});

// handle printable keystrokes including space
window.addEventListener('keypress', e=>{
  if(finished) return;
  // start timer on first keypress
  if(!startTime) startTime = performance.now();

  const ch = e.key; // includes space as ' '
  // ignore non-printable
  if(ch.length !== 1) return;

  // Record timestamp for player's CPS smoothing
  const now = performance.now();
  playerTimestamps.push(now);
  // prune old samples (keep last 6s)
  const cutoff = now - 6000;
  while(playerTimestamps.length && playerTimestamps[0] < cutoff) playerTimestamps.shift();

  // If the typed char matches the next required char -> advance
  const expected = prompt.charAt(index);
  if(ch === expected){
    index++;
    // advance car; correct char consumes nothing from errorQueue (errorQueue remains displayed but does not block)
    // We might clear queued errors when a correct char typed? No — per Option C they persist as queue (visual noise).
  } else {
    // Wrong char -> add to errorQueue (does NOT advance index)
    errorQueue += ch;
    errors++;
  }

  updateDisplays();
  checkFinish();
});

/* ======= PLAYER METRICS ======= */
function computePlayerCPS(){
  if(!startTime) return 0;
  const now = performance.now();
  const windowMs = 4000; // 4-second window for responsiveness
  const cutoff = now - windowMs;
  const recent = playerTimestamps.filter(t => t >= cutoff).length;
  return recent / (windowMs / 1000);
}
function computePlayerWPM(){
  const cps = computePlayerCPS();
  return Math.round((cps * 60) / 5);
}

/* ======= AI Behaviour ======= */
let lastAiTick = performance.now();
function updateAI(dt){
  // target based on player's recent cps with randomness
  const playerCps = computePlayerCPS() || 2.2;
  const randFactor = 0.88 + Math.random()*0.28; // 0.88 - 1.16
  const target = Math.max(0.5, playerCps * randFactor);
  // smooth AI speed (so it doesn't jitter too hard)
  const smooth = 0.09;
  aiSpeedCPS += (target - aiSpeedCPS) * smooth;
  // advance AI progress
  aiIndex += aiSpeedCPS * dt;
  // simulate occasional AI errors (won't block it since AI doesn't backspace)
  const approxCharsAdvanced = aiSpeedCPS * dt;
  const chancePerChar = 0.04; // baseline
  for(let i=0;i<Math.floor(approxCharsAdvanced)+1;i++){
    if(Math.random() < chancePerChar) aiErrors++;
  }
}

/* ======= RENDERING ======= */
function drawTrack(){
  // clear
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // draw background stripes and tracks
  ctx.fillStyle = '#071420';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // tracks
  for(let t=0;t<2;t++){
    const y = TRACK_Y[t];
    ctx.fillStyle = '#0d2236';
    ctx.fillRect(START_X-16, y-18, FINISH_X - START_X + 32, 44);
    // dashed markers for pixel look
    for(let x=START_X; x<FINISH_X; x+=20){
      ctx.fillStyle = (x%40===0)? '#17324a' : '#0f2a40';
      ctx.fillRect(x, y-12, 12, 2);
    }
  }

  // finish line
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(FINISH_X, 18, 6, canvas.height-36);
  // checker flag squares
  for(let i=0;i<8;i++){
    ctx.fillStyle = (i%2===0)? '#000' : '#fff';
    ctx.fillRect(FINISH_X+8, 22 + i*18, 12, 12);
  }
}

function drawCar(x, y, colorLabel, label){
  // shadow
  ctx.fillStyle = 'rgba(0,0,0,0.28)';
  ctx.fillRect(x+2, y+20, 40, 8);

  // body
  ctx.fillStyle = colorLabel;
  ctx.fillRect(x, y, 40, 18);
  // cabin
  ctx.fillRect(x+8, y-8, 24, 10);
  // wheels
  ctx.fillStyle = '#0b0b0b';
  ctx.fillRect(x+4, y+16, 8, 6);
  ctx.fillRect(x+28, y+16, 8, 6);
  // window
  ctx.fillStyle = 'rgba(255,255,255,0.18)';
  ctx.fillRect(x+12, y-6, 8, 6);
  ctx.fillRect(x+22, y-6, 6, 6);
  // label
  ctx.fillStyle = '#08101a';
  ctx.font = '10px monospace';
  ctx.fillText(label, x+6, y+12);
}

function draw(){
  drawTrack();

  // compute progresses (0..1)
  const playerProg = Math.min(1, index / Math.max(1, prompt.length));
  const aiProg = Math.min(1, aiIndex / Math.max(1, prompt.length));

  const range = FINISH_X - START_X - 40;
  const playerX = START_X + range * playerProg;
  const aiX = START_X + range * aiProg;

  drawCar(aiX, TRACK_Y[0]-4, '#6ba6ff', 'AI');
  drawCar(playerX, TRACK_Y[1]-4, '#ff6b6b', 'YOU');

  // small progress bars
  ctx.fillStyle = '#13243a';
  ctx.fillRect(START_X, TRACK_Y[1] + 32, FINISH_X - START_X, 6);
  ctx.fillStyle = '#2be08a';
  ctx.fillRect(START_X, TRACK_Y[1] + 32, (FINISH_X - START_X) * playerProg, 6);
  ctx.fillStyle = '#13243a';
  ctx.fillRect(START_X, TRACK_Y[0] + 32, FINISH_X - START_X, 6);
  ctx.fillStyle = '#6ba6ff';
  ctx.fillRect(START_X, TRACK_Y[0] + 32, (FINISH_X - START_X) * aiProg, 6);

  // HUD
  ctx.fillStyle = '#9fb2ff';
  ctx.font = '12px monospace';
  ctx.fillText('AI', START_X-28, TRACK_Y[0]+4);
  ctx.fillText('YOU', START_X-34, TRACK_Y[1]+4);

  // finished display if needed
  if(finished){
    ctx.fillStyle = '#ffd66b';
    ctx.font = '18px monospace';
    ctx.fillText('RACE FINISHED', canvas.width/2 - 72, 28);
  }

  // update live stats in UI
  liveCps.innerText = computePlayerCPS().toFixed(2);
  liveWpm.innerText = computePlayerWPM();
  liveErrors.innerText = errors;
  liveProgress.innerText = Math.round(playerProg*100) + '%';
}

/* ======= DISPLAY PROMPT & TYPED ======= */
function updateDisplays(){
  // typed correct segment (green)
  const correctText = escapeHtml(prompt.slice(0, index));
  const correctHtml = `<span class="correct">${correctText}</span>`;
  // errorQueue rendered in red (queued)
  const wrongHtml = errorQueue ? `<span class="wrong">${escapeHtml(errorQueue)}</span>` : '';
  typedLine.innerHTML = correctHtml + wrongHtml;
  expectedLine.innerText = prompt.slice(index);
}

/* ======= FINISH CHECK & STATS ======= */
function checkFinish(){
  // player finish
  if(index >= prompt.length && !finished){
    finished = true;
    finishRace('You');
    return;
  }
  // ai finish
  if(Math.floor(aiIndex) >= prompt.length && !finished){
    finished = true;
    finishRace('AI');
    return;
  }
}

function finishRace(winnerGuess){
  const end = performance.now();
  const elapsed = ((end - (startTime||end))/1000) || 0;
  const cps = (index / Math.max(elapsed, 0.0001));
  const wpm = Math.round((cps*60)/5);
  const accuracy = Math.round(100 * ((Math.max(0,index - errors)) / Math.max(1, index + (errorQueue.length))));
  const winner = (index >= prompt.length && Math.floor(aiIndex) >= prompt.length) ? (index/ (index + 0.0001) >= aiIndex/(aiIndex+0.0001) ? 'You' : 'AI') : (index >= prompt.length ? 'You' : 'AI');

  showStatsModal({
    prompt,
    elapsed: elapsed.toFixed(2),
    cps: cps.toFixed(2),
    wpm,
    errors,
    aiErrors,
    aiCps: aiSpeedCPS.toFixed(2),
    accuracy,
    winner
  });
}

/* ======= STATS MODAL ======= */
function showStatsModal(stats){
  modalWrap.style.display = 'flex';
  modalWrap.innerHTML = `
    <div class="modal-backdrop" id="backdrop">
      <div class="modal" role="dialog" aria-modal="true">
        <h2>Race Results — ${escapeHtml(stats.winner)}</h2>
        <div style="color:var(--muted);margin-top:6px">Prompt: "${escapeHtml(stats.prompt)}"</div>
        <div class="grid">
          <div><strong>Time</strong><div>${stats.elapsed} s</div></div>
          <div><strong>WPM</strong><div>${stats.wpm}</div></div>
          <div><strong>CPS (you)</strong><div>${stats.cps}</div></div>
          <div><strong>CPS (AI)</strong><div>${stats.aiCps}</div></div>
          <div><strong>Errors (you)</strong><div>${stats.errors}</div></div>
          <div><strong>Errors (AI)</strong><div>${stats.aiErrors}</div></div>
          <div><strong>Accuracy</strong><div>${stats.accuracy}%</div></div>
          <div><strong>Winner</strong><div>${escapeHtml(stats.winner)}</div></div>
        </div>
        <div style="display:flex;gap:8px;justify-content:flex-end;">
          <button id="modalNew">New Race</button>
          <button id="modalClose">Close</button>
        </div>
      </div>
    </div>
  `;
  document.getElementById('modalNew').addEventListener('click', ()=>{
    modalWrap.style.display = 'none';
    newRace();
  });
  document.getElementById('modalClose').addEventListener('click', ()=>{
    modalWrap.style.display = 'none';
  });
}

/* ======= MAIN LOOPS ======= */
let lastFrame = performance.now();
function mainLoop(now){
  const dt = (now - lastFrame) / 1000;
  lastFrame = now;
  if(!finished){
    updateAI(dt);
    draw();
    checkFinish();
  }
  requestAnimationFrame(mainLoop);
}
requestAnimationFrame(mainLoop);

/* ======= BUTTONS & UI ======= */
newBtn.addEventListener('click', ()=>{
  newRace();
  promptArea.focus();
});
skipBtn.addEventListener('click', ()=>{
  newRace();
  promptArea.focus();
});
randomToggle.addEventListener('click', ()=>{
  randomPrompts = !randomPrompts;
  randomToggle.innerText = `Random Prompts: ${randomPrompts ? 'ON' : 'OFF'}`;
});

/* focus the prompt area so keypress works immediately */
promptArea.addEventListener('click', ()=> promptArea.focus());
promptArea.focus();

/* keep displays in sync with initial prompt */
updateDisplays();

/* Expose basic keyboard focus for mobile / tablet: capture keypresses via window as well */
window.addEventListener('focus', ()=> promptArea.focus());

</script>
</body>
</html>

